name: Apex PMD Scan (PRs, CSV, fail-on-violation)

on:
  pull_request:
    branches:
      - '**'

jobs:
  apex-pmd-scan-pull:
    name: apex-pmd-scan-pull
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Use Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install ESLint (DO NOT MODIFY package.json)
        run: npm install eslint --no-save --legacy-peer-deps

      - name: Set up Java 17
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: "17"

      - name: Install Salesforce CLI
        run: npm install @salesforce/cli --global

      - name: Disable Auto Plugin Install
        run: |
          mkdir -p ~/.sf
          echo '{"plugins":{"autoInstall":false}}' > ~/.sf/sf-config.json
      - name: Install Code Analyzer Plugin v5
        run: |
          sf plugins uninstall @salesforce/plugin-code-analyzer || true
          sf plugins install @salesforce/plugin-code-analyzer@5.1.0
      - name: Confirm Only v5 Plugin
        run: sf plugins | grep code-analyzer

      - name: Get Commit Author
        id: commit-author
        run: |
          AUTHOR_NAME=$(git log -1 --pretty=format:'%an')
          AUTHOR_EMAIL=$(git log -1 --pretty=format:'%ae')
          COMMITTER_NAME=$(git log -1 --pretty=format:'%cn')
          COMMITTER_EMAIL=$(git log -1 --pretty=format:'%ce')
          echo "Author: $AUTHOR_NAME <$AUTHOR_EMAIL>"
          echo "Committer: $COMMITTER_NAME <$COMMITTER_EMAIL>"
          echo "commit-author=$AUTHOR_NAME" >> $GITHUB_OUTPUT
          echo "GITHUB_USERNAME=$AUTHOR_NAME" >> $GITHUB_ENV
          echo "COMMIT_AUTHOR=$AUTHOR_NAME" >> $GITHUB_ENV
      - name: Get Repository and Branch Info
        shell: bash
        run: |
          set -euo pipefail
          REPO_NAME="$(echo "${GITHUB_REPOSITORY}" | cut -d'/' -f2)"
          # ‚úÖ Target branch for PRs (base branch)
          if [[ "${GITHUB_EVENT_NAME}" == "pull_request" ]]; then
            TARGET_BRANCH="${GITHUB_BASE_REF}"
            SOURCE_BRANCH="${GITHUB_HEAD_REF}"
          else
            TARGET_BRANCH="${GITHUB_REF#refs/heads/}"
            SOURCE_BRANCH="${TARGET_BRANCH}"
          fi
          COMMIT_LABEL="$(git log -1 --pretty=format:'%s')"
          echo "REPO_NAME=${REPO_NAME}" >> "$GITHUB_ENV"
          echo "TARGET_BRANCH=${TARGET_BRANCH}" >> "$GITHUB_ENV"
          echo "SOURCE_BRANCH=${SOURCE_BRANCH}" >> "$GITHUB_ENV"
          echo "COMMIT_LABEL=${COMMIT_LABEL}" >> "$GITHUB_ENV"
          FILE_TITLE="Code Scanner Report_${REPO_NAME}_${TARGET_BRANCH}_${COMMIT_LABEL}"
          echo "Target Branch = ${TARGET_BRANCH}"
          echo "Source Branch = ${SOURCE_BRANCH}"
          echo "FILE_TITLE=${FILE_TITLE}" >> $GITHUB_ENV
      # ------------------------------------------------------------
      # 1) Resolve the diff range and collect changed files by type
      # ------------------------------------------------------------
      - name: Resolve diff range & collect changed files
        id: collect-delta-files
        shell: bash
        run: |
          set -euo pipefail
          echo "Resolving diff range..."
          git fetch --no-tags --prune --depth=50 origin +refs/heads/*:refs/remotes/origin/*
          if [[ "${{ github.event_name }}" == "pull_request" && -n "${{ github.base_ref }}" ]]; then
            RANGE="origin/${{ github.base_ref }}...${{ github.sha }}"
            echo "Using PR diff range: $RANGE"
          else
            RANGE="HEAD~1..HEAD"
            echo "Using fallback diff range: $RANGE"
          fi
          echo "RANGE=$RANGE" >> "$GITHUB_OUTPUT"
          changed_files=$(git diff --name-only $RANGE -- '*.cls' '*.js' '*.html' || true)
          if [[ -z "$changed_files" ]]; then
            echo "‚ö†Ô∏è No changes detected for .cls/.js/.html."
            echo "has_changes=false" >> "$GITHUB_OUTPUT"
          else
            printf "%s\n" $changed_files | sort -u > changed_files.txt
            echo "Detected changed files:"
            cat changed_files.txt
            echo "has_changes=true" >> "$GITHUB_OUTPUT"
          fi
      # ------------------------------------------------------------
      # 2) Get delta added lines & create temp files
      #    ‚úÖ WITH mapping: line_number_mapping.txt (tempLine -> actualLine)
      # ------------------------------------------------------------
      - name: Get changed lines and create temporary files (delta, with Apex wrapper; WITH mapping)
        shell: bash
        id: get-changes
        run: |
          set -euo pipefail

          mkdir -p temp_scanner_files
          : > changed_cls_lwc_files.txt
          : > line_number_mapping.txt

          echo "Checking for changed .cls, .js, .html files..."

          if [[ "${{ github.event_name }}" == "pull_request" && -n "${{ github.base_ref }}" ]]; then
            RANGE="origin/${{ github.base_ref }}...${{ github.sha }}"
            echo "Using PR diff: $RANGE"
            git fetch --no-tags --prune origin +refs/heads/*:refs/remotes/origin/*
          else
            RANGE="HEAD~1..HEAD"
            echo "Using fallback diff: $RANGE"
          fi

          # ‚úÖ IMPORTANT: Get file status (A, M, D)
          git diff --name-status "$RANGE" -- '*.cls' '*.js' '*.html' > changed_status.txt || true

          if [[ ! -s changed_status.txt ]]; then
            echo "No .cls/.js/.html files detected."
            echo "rule,engine,severity,tags,file,startLine,startColumn,endLine,endColumn,message,resources,CommitAuthor,CommitAuthorFirstName,ActualLine,TargetBranch" > scanner-report.csv
            exit 0
          fi

          TAB=$(printf '\t')

          while read -r status file; do

            [[ -f "$file" ]] || { echo "Skipping deleted file: $file"; continue; }

            echo "Processing file: $file (Status: $status)"

            sanitized="${file//\//_}"

            # =====================================================
            # ‚úÖ IF NEW APEX CLASS ‚Üí SCAN FULL FILE DIRECTLY
            # =====================================================
            if [[ "$status" == "A" && "$file" == *.cls ]]; then
              echo "üÜï New Apex class detected. Scanning full file directly."
              echo "$file" >> changed_cls_lwc_files.txt
              continue
            fi

            # =====================================================
            # üîÅ FOR MODIFIED FILES ‚Üí USE EXISTING DELTA LOGIC
            # =====================================================

            git diff -U0 "$RANGE" -- "$file" | awk '
              /^@@/ {
                line = $0
                sub(/^.*\+/, "", line)
                sub(/,.*/, "", line)
                newLine = line + 0
                next
              }
              /^diff / || /^index / || /^--- / || /^\+\+\+ / { next }
              /^\+/ {
                print newLine "\t" substr($0,2)
                newLine++
                next
              }
            ' > lines.tmp || true

            if [[ ! -s lines.tmp ]]; then
              echo "No added lines found for $file (possibly only deletions). Skipping..."
              continue
            fi

            case "$file" in
              *.cls)

                temp_file="temp_scanner_files/temp_${sanitized%.cls}.cls"

                echo "public with sharing class TempWrapper_${sanitized//[^A-Za-z0-9_]/_} {" > "$temp_file"
                temp_line=1
                echo "$temp_file,$temp_line,0" >> line_number_mapping.txt
                ((temp_line++))

                echo "  public static void tempMethod() {" >> "$temp_file"
                echo "$temp_file,$temp_line,0" >> line_number_mapping.txt
                ((temp_line++))

                has_real_code=false

                while IFS= read -r row; do
                  actual_line="${row%%$TAB*}"
                  content="${row#*"$TAB"}"
                  trimmed="$(echo "$content" | sed 's/^[[:space:]]*//')"

                  if [[ -z "$(echo "$trimmed" | tr -d '[:space:]')" ]]; then continue; fi
                  if [[ "$trimmed" =~ ^// ]]; then continue; fi
                  if [[ "$trimmed" =~ ^/\* ]]; then continue; fi
                  if [[ "$trimmed" =~ ^\* ]]; then continue; fi
                  if [[ "$trimmed" =~ ^\*/ ]]; then continue; fi

                  has_real_code=true

                  printf "    %s\n" "$content" >> "$temp_file"
                  echo "$temp_file,$temp_line,$actual_line" >> line_number_mapping.txt
                  ((temp_line++))
                done < lines.tmp

                if [[ "$has_real_code" == false ]]; then
                  echo "‚ö†Ô∏è Only comments detected in $file. Skipping wrapper generation."
                  rm -f "$temp_file"
                  continue
                fi

                echo "  }" >> "$temp_file"
                echo "$temp_file,$temp_line,0" >> line_number_mapping.txt
                ((temp_line++))

                echo "}" >> "$temp_file"
                echo "$temp_file,$temp_line,0" >> line_number_mapping.txt

                echo "$temp_file" >> changed_cls_lwc_files.txt
                echo "Created temp file: $temp_file"
                ;;

              *.js)

                temp_file="temp_scanner_files/temp_${sanitized%.js}.js"

                temp_line=1
                echo "/* delta-only temp JS */" > "$temp_file"
                echo "$temp_file,$temp_line,0" >> line_number_mapping.txt
                ((temp_line++))

                while IFS= read -r row; do
                  actual_line="${row%%$TAB*}"
                  content="${row#*"$TAB"}"

                  if [[ -n "$(echo "$content" | sed 's/[[:space:]]//g')" ]]; then
                    printf "%s\n" "$content" >> "$temp_file"
                    echo "$temp_file,$temp_line,$actual_line" >> line_number_mapping.txt
                    ((temp_line++))
                  fi
                done < lines.tmp

                echo "$temp_file" >> changed_cls_lwc_files.txt
                ;;
              *.html)

                temp_file="temp_scanner_files/temp_${sanitized%.html}.html"

                temp_line=1
                echo "<template>" > "$temp_file"
                echo "$temp_file,$temp_line,0" >> line_number_mapping.txt
                ((temp_line++))

                while IFS= read -r row; do
                  actual_line="${row%%$TAB*}"
                  content="${row#*"$TAB"}"

                  if [[ -n "$(echo "$content" | sed 's/[[:space:]]//g')" ]]; then
                    printf "%s\n" "$content" >> "$temp_file"
                    echo "$temp_file,$temp_line,$actual_line" >> line_number_mapping.txt
                    ((temp_line++))
                  fi
                done < lines.tmp

                echo "</template>" >> "$temp_file"
                echo "$temp_file,$temp_line,0" >> line_number_mapping.txt

                echo "$temp_file" >> changed_cls_lwc_files.txt
                ;;

            esac

          done < changed_status.txt
          echo "====== Generated files list ======"
          if [[ -s changed_cls_lwc_files.txt ]]; then
            cat changed_cls_lwc_files.txt
          else
            echo "No temp files created. Exiting."
            exit 0
          fi
          echo "====== line_number_mapping.txt (first 50) ======"
          head -n 50 line_number_mapping.txt || true
      # ‚úÖ NEW: Print temp wrapper class (content) so you can confirm what got scanned
      - name: DEBUG ‚Äì Print temp wrapper classes
        shell: bash
        run: |
          set -euo pipefail
          echo "==== temp_scanner_files listing ===="
          ls -lah temp_scanner_files || true
          echo "==== Print all temp .cls wrappers (with line numbers) ===="
          shopt -s nullglob
          for f in temp_scanner_files/*.cls; do
            echo ""
            echo "--------------------------------------------------"
            echo "TEMP WRAPPER: $f"
            echo "--------------------------------------------------"
            nl -ba "$f" | sed -n '1,220p'
          done
          echo ""
          echo "==== Grep for System.debug in temp wrappers ===="
          grep -RIn --line-number "System\.debug" temp_scanner_files || echo "‚ùå No System.debug found in temp wrappers"
      # ------------------------------------------------------------
      # 3) Build lookup map (basename|tempLine=actualLine)
      # ------------------------------------------------------------
      - name: Build Actual Line Lookup
        shell: bash
        run: |
          set -euo pipefail
          : > actual_line_lookup.env
          if [[ -s line_number_mapping.txt ]]; then
            awk -F',' '
              {
                fullpath=$1
                tempLine=$2
                actualLine=$3
                n=split(fullpath, arr, "/")
                file=arr[n]
                print file "|" tempLine "=" actualLine
              }
            ' line_number_mapping.txt > actual_line_lookup.env
          fi
          echo "=== ACTUAL LINE LOOKUP (first 50) ==="
          head -n 50 actual_line_lookup.env || true
      # ------------------------------------------------------------
      # 4) Build files_to_scan.txt
      # ------------------------------------------------------------
      - name: Build files_to_scan.txt from temp files
        shell: bash
        run: |
          set -euo pipefail
          : > files_to_scan.txt
          if [[ -f changed_cls_lwc_files.txt && -s changed_cls_lwc_files.txt ]]; then
            while read -r f; do
              [[ -n "$f" && -f "$f" ]] && echo "$f"
            done < changed_cls_lwc_files.txt > files_to_scan.txt
          fi
          echo "====== files_to_scan.txt ======"
          if [[ -s files_to_scan.txt ]]; then
            cat files_to_scan.txt
          else
            echo "No files to scan."
          fi
      # ------------------------------------------------------------
      # 5) Run Code Analyzer v5 on delta temp files and build CSV
      #    ‚úÖ CommitAuthor = col12
      #    ‚úÖ ActualLine  = col13
      #    ‚úÖ TargetBranch= col14
      # ------------------------------------------------------------
      - name: Run SFDX Scanner (Code Analyzer v5) + add ActualLine
        shell: bash
        run: |
          set -euo pipefail
          # Load lookup into memory
          declare -A ACTUAL_LINE_MAP
          if [[ -s actual_line_lookup.env ]]; then
            while IFS='=' read -r key value; do
              ACTUAL_LINE_MAP["$key"]="$value"
            done < actual_line_lookup.env
          fi
          # Final header (NO NYA)
          echo "rule,engine,severity,tags,file,startLine,startColumn,endLine,endColumn,message,resources,CommitAuthor,CommitAuthorFirstName,ActualLine,TargetBranch" > scanner-report.csv
          if [[ ! -s files_to_scan.txt ]]; then
            echo "‚úÖ Nothing to scan. Empty report created."
            exit 0
          fi
          while read -r file; do
            [[ -z "$file" ]] && continue
            echo "üîç Scanning $file"
            rm -f tmp.csv
            if [[ "$file" == *.cls ]]; then
              sf code-analyzer run \
                --workspace "$file" \
                --rule-selector ApexCRUDViolation \
                --rule-selector ApexBadCrypto \
                --rule-selector ApexDangerousMethods \
                --rule-selector ApexInsecureEndpoint \
                --rule-selector ApexOpenRedirect \
                --rule-selector ApexSharingViolations \
                --rule-selector ApexSOQLInjection \
                --rule-selector ApexSuggestUsingNamedCred \
                --rule-selector ApexXSSFromEscapeFalse \
                --rule-selector ApexXSSFromURLParam \
                --rule-selector AvoidDebugStatements \
                --rule-selector AvoidNonRestrictiveQueries \
                --rule-selector EagerlyLoadedDescribeSObjectResult \
                --rule-selector OperationWithHighCostInLoop \
                --rule-selector OperationWithLimitsInLoop \
                --rule-selector ApexCSRF \
                --rule-selector AvoidDirectAccessTriggerMap \
                --rule-selector AvoidHardcodingId \
                --rule-selector EmptyCatchBlock \
                --rule-selector UnusedLocalVariable \
                --rule-selector QueueableWithoutFinalizer \
                --rule-selector IfElseStmtsMustUseBraces \
                --rule-selector ForLoopsMustUseBraces \
                --rule-selector AvoidDeeplyNestedIfStmts \
                --rule-selector DebugsShouldUseLoggingLevel \
                --rule-selector ApexUnitTestShouldNotUseSeeAllDataTrue \
                --rule-selector EmptyStatementBlock \
                --rule-selector EmptyTryOrFinallyBlock \
                --rule-selector CognitiveComplexity \
                --rule-selector TooManyFields \
                --rule-selector ExcessiveParameterList \
                --rule-selector ExcessiveClassLength \
                --rule-selector NcssConstructorCount \
                --rule-selector NcssMethodCount \
                --rule-selector NcssTypeCount \
                --rule-selector ExcessivePublicCount \
                --rule-selector CyclomaticComplexity \
                --rule-selector StdCyclomaticComplexity \
                --rule-selector ApexUnitTestClassShouldHaveAsserts \
                --output-file tmp.csv \
                --config-file code-analyzer.yml \
              || echo "‚ö†Ô∏è Code Analyzer failed for $file (continuing to build report)"
            else
              sf code-analyzer run \
                --workspace "$file" \
                --engine eslint \
                --output-file tmp.csv \
              || echo "‚ö†Ô∏è ESLint analyzer failed for $file (continuing to build report)"
            fi
            if [[ -f tmp.csv ]]; then
              isTemp=0
              [[ "$file" == temp_scanner_files/* ]] && isTemp=1
              tempBase="$(basename "$file")"
              tail -n +2 tmp.csv | while IFS= read -r row; do
                [[ -z "$row" ]] && continue
                startLine=$(echo "$row" | awk -F',' '{print $6}' | tr -d '"')
                actualLine="$startLine"
                if [[ "$isTemp" -eq 1 ]]; then
                  key="${tempBase}|${startLine}"
                  if [[ -n "${ACTUAL_LINE_MAP[$key]+x}" ]]; then
                    mapped="${ACTUAL_LINE_MAP[$key]}"
                  else
                    mapped="N/A"
                  fi

                  [[ -z "$mapped" || "$mapped" == "0" ]] && mapped="N/A"
                  actualLine="$mapped"
                fi
                echo "${row},${COMMIT_AUTHOR},${COMMIT_AUTHOR},${actualLine},${TARGET_BRANCH}" >> scanner-report.csv
              done
            fi
          done < files_to_scan.txt
          echo "‚úÖ Final Scanner Report (first 50 lines):"
          head -n 50 scanner-report.csv

 # ------------------------------------------------------------
      # ‚úÖ 6) NEW: Build separate LWC-only report using ESLint v10
      # ------------------------------------------------------------
      - name: Generate LWC-only ESLint v10 report (lwc-scanner-report.csv)
        shell: bash
        run: |
          set -euo pipefail

          # Load lookup into memory (for temp js/html -> actual line mapping)
          declare -A ACTUAL_LINE_MAP
          if [[ -s actual_line_lookup.env ]]; then
            while IFS='=' read -r key value; do
              ACTUAL_LINE_MAP["$key"]="$value"
            done < actual_line_lookup.env
          fi

          echo "rule,engine,severity,tags,file,startLine,startColumn,endLine,endColumn,message,resources,CommitAuthor,CommitAuthorFirstName,ActualLine,TargetBranch" > lwc-scanner-report.csv

          if [[ ! -s files_to_scan.txt ]]; then
            echo "‚úÖ Nothing to scan for LWC. Empty lwc report created."
            exit 0
          fi

          while read -r file; do
            [[ -z "$file" ]] && continue

            # Only js/html (your LWC delta temp files)
            if [[ "$file" != *.js && "$file" != *.html ]]; then
              continue
            fi

            # üö´ Skip eslint config file
            if [[ "$file" == *eslint.config.js ]]; then
              continue
            fi

            echo "üü¶ ESLint v10 scanning (LWC report): $file"
            rm -f eslint-output.json

            # ESLint v10 reads eslint.config.js from repo root automatically
            npx eslint "$file" -f json -o eslint-output.json || true

            if [[ ! -s eslint-output.json ]]; then
              continue
            fi

            isTemp=0
            [[ "$file" == temp_scanner_files/* ]] && isTemp=1
            tempBase="$(basename "$file")"

            # eslint-output.json is array of file results
            jq -c '.[]' eslint-output.json | while read -r entry; do
              filePath=$(echo "$entry" | jq -r '.filePath // ""')
              jq -c '.messages[]?' <<< "$entry" | while read -r msg; do
                rule=$(echo "$msg" | jq -r '.ruleId // "UnknownRule"')
                sev=$(echo "$msg" | jq -r '.severity // 0')
                line=$(echo "$msg" | jq -r '.line // 0')
                message=$(echo "$msg" | jq -r '.message // ""' | sed 's/"/""/g')

                actualLine="$line"
                if [[ "$isTemp" -eq 1 ]]; then
                  key="${tempBase}|${line}"
                  if [[ -n "${ACTUAL_LINE_MAP[$key]+x}" ]]; then
                    mapped="${ACTUAL_LINE_MAP[$key]}"
                  else
                    mapped="N/A"
                  fi

                  [[ -z "$mapped" || "$mapped" == "0" ]] && mapped="N/A"
                  actualLine="$mapped"
                fi

                # keep same CSV shape as your main report
                echo "\"$rule\",eslint,$sev,,\"$file\",$line,0,$line,0,\"$message\",,${COMMIT_AUTHOR},${COMMIT_AUTHOR},${actualLine},${TARGET_BRANCH}" >> lwc-scanner-report.csv
              done
            done

          done < files_to_scan.txt

          echo "‚úÖ LWC-only report (first 50 lines):"
          head -n 50 lwc-scanner-report.csv

      - name: Authenticate with Salesforce
        id: sf-auth
        run: |
          response=$(curl -X POST "https://login.salesforce.com/services/oauth2/token" \
            -d "grant_type=password" \
            -d "client_id=${{ secrets.SF_CLIENT_ID }}" \
            -d "client_secret=${{ secrets.SF_CLIENT_SECRET }}" \
            -d "username=${{ secrets.SF_USERNAME }}" \
            -d "password=${{ secrets.SF_PASSWORD }}${{ secrets.SF_SECURITY_TOKEN }}" )
          SF_ACCESS_TOKEN=$(echo "$response" | jq -r '.access_token')
          if [ -z "$SF_ACCESS_TOKEN" ]; then
            echo "Salesforce authentication failed."
            exit 1
          fi
          echo "SF_ACCESS_TOKEN=$SF_ACCESS_TOKEN" >> $GITHUB_ENV
          echo "Successfully authenticated with Salesforce."
      - name: Upload Scanner Report to Salesforce
        if: success()
        run: |
          violation_count=$(tail -n +2 scanner-report.csv | wc -l)
          if [ "$violation_count" -eq 0 ]; then
            echo "No violations found. Skipping Salesforce upload."
            exit 0
          fi
          echo "Uploading scanner report to Salesforce..."
          response=$(curl -X POST "${{ vars.SF_DOMAIN_URL }}/services/data/v61.0/sobjects/ContentVersion" \
            -H "Authorization: Bearer $SF_ACCESS_TOKEN" \
            -H "Content-Type: multipart/form-data" \
            -F "entity_content={\"Title\": \"${{ env.FILE_TITLE }}\", \"PathOnClient\": \"scanner-report.csv\"};type=application/json" \
            -F "VersionData=@scanner-report.csv;type=text/csv")
          echo "Salesforce API Response: $response"
          contentVersionId=$(echo "$response" | jq -r 'if type=="array" then .[0].id else .id end' 2>/dev/null || echo "null")
          if [[ "$contentVersionId" == "null" || -z "$contentVersionId" ]]; then
            echo "Error: Failed to extract ContentVersion ID from response."
            echo "Full API Response: $response"
            exit 1
          fi
          echo "Successfully uploaded scanner report to Salesforce."
      # ‚úÖ NEW upload for LWC report
      - name: Upload LWC Scanner Report to Salesforce
        if: success()
        run: |
          if [[ ! -f lwc-scanner-report.csv ]]; then
            echo "lwc-scanner-report.csv not found, skipping."
            exit 0
          fi

          violation_count=$(tail -n +2 lwc-scanner-report.csv | wc -l)
          if [ "$violation_count" -eq 0 ]; then
            echo "No LWC violations found. Skipping Salesforce upload."
            exit 0
          fi

          echo "Uploading LWC scanner report to Salesforce..."
          curl -X POST "${{ vars.SF_DOMAIN_URL }}/services/data/v61.0/sobjects/ContentVersion" \
            -H "Authorization: Bearer $SF_ACCESS_TOKEN" \
            -H "Content-Type: multipart/form-data" \
            -F "entity_content={\"Title\": \"LWC_${{ env.FILE_TITLE }}\", \"PathOnClient\": \"lwc-scanner-report.csv\"};type=application/json" \
            -F "VersionData=@lwc-scanner-report.csv;type=text/csv"

      - name: Ensure Scanner Reports Exist
        if: always()
        run: |
          if [ ! -s scanner-report.csv ]; then
            echo "No scanner report generated, creating a dummy report."
            echo "rule,engine,severity,tags,file,startLine,startColumn,endLine,endColumn,message,resources,CommitAuthor,CommitAuthorFirstName,ActualLine,TargetBranch" > scanner-report.csv
          fi
          if [ ! -s lwc-scanner-report.csv ]; then
            echo "No LWC scanner report generated, creating a dummy report."
            echo "rule,engine,severity,tags,file,startLine,startColumn,endLine,endColumn,message,resources,CommitAuthor,CommitAuthorFirstName,ActualLine,TargetBranch" > lwc-scanner-report.csv
          fi

      - name: Debug - List Files Before Upload
        if: always()
        run: |
          echo "Listing files before uploading scanner report:"
          ls -lah


      # ‚úÖ Existing gate remains (uses scanner-report.csv)
      # ‚úÖ FINAL FIXED GATE (correct file + severity counting)
      - name: HARD FAIL Block PR on Violations + Severity buckets
        shell: bash
        run: |
          set -euo pipefail

          if [[ ! -f scanner-report.csv ]]; then
            echo "‚ùå scanner-report.csv not found"
            exit 1
          fi

          if [[ ! -f lwc-scanner-report.csv ]]; then
            echo "‚ùå lwc-scanner-report.csv not found"
            exit 1
          fi

          echo "üîç Evaluating scanner-report.csv and lwc-scanner-report.csv"

          # --------------------------------------------------
          # 1Ô∏è‚É£ Severity 1-2 (BLOCKING) ‚Äì FIXED LOGIC
          # --------------------------------------------------
          sev_1_2_apex=$(awk -F',' '
            NR>1 {
              sev=$3
              gsub(/"/,"",sev)
              if (sev ~ /^[0-9]+$/) {
                s = sev + 0
                if (s==1 || s==2) c++
              }
            }
            END { print c+0 }
          ' scanner-report.csv)

          sev_1_2_lwc=$(awk -F',' '
            NR>1 {
              sev=$3
              gsub(/"/,"",sev)
              if (sev ~ /^[0-9]+$/) {
                s = sev + 0
                if (s==1 || s==2) c++
              }
            }
            END { print c+0 }
          ' lwc-scanner-report.csv)

          sev_1_2_total=$((sev_1_2_apex + sev_1_2_lwc))

          # --------------------------------------------------
          # 2Ô∏è‚É£ Severity 3-5
          # --------------------------------------------------
          sev_3_5_apex=$(awk -F',' '
            NR>1 {
              sev=$3
              gsub(/"/,"",sev)
              if (sev ~ /^[0-9]+$/) {
                s = sev + 0
                if (s>=3 && s<=5) c++
              }
            }
            END { print c+0 }
          ' scanner-report.csv)

          sev_3_5_lwc=$(awk -F',' '
            NR>1 {
              sev=$3
              gsub(/"/,"",sev)
              if (sev ~ /^[0-9]+$/) {
                s = sev + 0
                if (s>=3 && s<=5) c++
              }
            }
            END { print c+0 }
          ' lwc-scanner-report.csv)

          sev_3_5_total=$((sev_3_5_apex + sev_3_5_lwc))

          # --------------------------------------------------
          # 3Ô∏è‚É£ Apex Count (.cls)
          # --------------------------------------------------
          apex_total=$(awk -F',' '
            NR>1 {
              file=$5
              gsub(/"/,"",file)
              if (file ~ /\.cls$/) c++
            }
            END { print c+0 }
          ' scanner-report.csv)

          # --------------------------------------------------
          # 4Ô∏è‚É£ JS / HTML Count (both reports)
          # --------------------------------------------------
          js_main=$(awk -F',' '
            NR>1 {
              file=$5
              gsub(/"/,"",file)
              if (file ~ /\.js$/) c++
            }
            END { print c+0 }
          ' scanner-report.csv)

          js_lwc=$(awk -F',' '
            NR>1 {
              file=$5
              gsub(/"/,"",file)
              if (file ~ /\.js$/) c++
            }
            END { print c+0 }
          ' lwc-scanner-report.csv)

          html_main=$(awk -F',' '
            NR>1 {
              file=$5
              gsub(/"/,"",file)
              if (file ~ /\.html$/) c++
            }
            END { print c+0 }
          ' scanner-report.csv)

          html_lwc=$(awk -F',' '
            NR>1 {
              file=$5
              gsub(/"/,"",file)
              if (file ~ /\.html$/) c++
            }
            END { print c+0 }
          ' lwc-scanner-report.csv)

          js_total=$((js_main + js_lwc))
          html_total=$((html_main + html_lwc))
          lwc_total=$((js_total + html_total))

          # --------------------------------------------------
          # 5Ô∏è‚É£ SUMMARY
          # --------------------------------------------------
          echo "================ SUMMARY ================"
          echo "Apex Violations (.cls)         : $apex_total"
          echo "JS Violations (.js)            : $js_total"
          echo "HTML Violations (.html)        : $html_total"
          echo "Total LWC Violations           : $lwc_total"
          echo "-----------------------------------------"
          echo "Severity 1-2 Violations        : $sev_1_2_total"
          echo "Severity 3-5 Violations        : $sev_3_5_total"
          echo "========================================="

          # --------------------------------------------------
          # 6Ô∏è‚É£ HARD BLOCK
          # --------------------------------------------------
          if [[ "$sev_1_2_total" -gt 0 ]]; then
            echo ""
            echo "üö´ HARD GATE FAILED ‚Äì Found severity 1-2 violations"
            echo ""
            echo "------ Apex Violations ------"
            sed -n '1,200p' scanner-report.csv || true
            echo ""
            echo "------ LWC Violations ------"
            sed -n '1,200p' lwc-scanner-report.csv || true
            exit 1
          fi

          echo "‚úÖ HARD GATE PASSED ‚Äì PR CAN MERGE"


      - name: Commit and Push Scanner Reports to `Scanner_Reports` Branch
        if: always()
        shell: bash
        env:
          GH_PAT: ${{ secrets.GH_PAT }}
        run: |
          set -euo pipefail

          BRANCH_NAME="Scanner_Reports"
          echo "‚úÖ Target Branch: $BRANCH_NAME"

          # 1Ô∏è‚É£ Save reports outside repo (to avoid conflicts)
          mkdir -p /tmp/scanner_reports
          cp scanner-report.csv /tmp/scanner_reports/scanner-report.csv
          cp lwc-scanner-report.csv /tmp/scanner_reports/lwc-scanner-report.csv

          # 2Ô∏è‚É£ HARD CLEAN repository (removes package.json changes + temp files)
          git reset --hard
          git clean -fd

          # 3Ô∏è‚É£ Configure git identity
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # 4Ô∏è‚É£ Use PAT for authenticated push
          git remote set-url origin "https://x-access-token:${GH_PAT}@github.com/${GITHUB_REPOSITORY}.git"

          # 5Ô∏è‚É£ Checkout Scanner_Reports cleanly
          git fetch origin "$BRANCH_NAME" || true
          if git show-ref --verify --quiet "refs/remotes/origin/$BRANCH_NAME"; then
            git checkout -B "$BRANCH_NAME" "origin/$BRANCH_NAME"
          else
            git checkout --orphan "$BRANCH_NAME"
            git rm -rf . >/dev/null 2>&1 || true
          fi

          # 6Ô∏è‚É£ Copy reports back into Artifact folder
          mkdir -p Artifact
          OUT_APEX="Artifact/${FILE_TITLE}.csv"
          OUT_LWC="Artifact/LWC_${FILE_TITLE}.csv"

          cp /tmp/scanner_reports/scanner-report.csv "$OUT_APEX"
          cp /tmp/scanner_reports/lwc-scanner-report.csv "$OUT_LWC"

          git add Artifact
          git commit -m "Add scanner reports (PR #${{ github.event.pull_request.number }}, run ${{ github.run_id }})" || echo "No changes to commit"
          git push -u origin "$BRANCH_NAME"