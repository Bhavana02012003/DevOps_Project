public with sharing class File {

    private static final String VULN_OBJECT_API = 'Vulnerability__c';

    /* ================= ENTRY ================= */

    public static void processNewFiles(List<ContentVersion> contentVersions) {
        Set<Id> contentDocIds = new Set<Id>();

        for (ContentVersion cv : contentVersions) {
            if (cv.ContentDocumentId != null) {
                contentDocIds.add(cv.ContentDocumentId);
            }
        }

        if (!contentDocIds.isEmpty()) {
            importVulnerabilityData(new List<Id>(contentDocIds));
        }
    }

    public static void processNewContentDocuments(Set<Id> contentDocIds) {
        createScannerReportCases(contentDocIds);
        importVulnerabilityData(new List<Id>(contentDocIds));
    }

    /* =========================================================
       üÜï FILE ‚Üí CASE MAP (STANDARD CASE OBJECT)
       ========================================================= */
    private static Map<Id, Id> getFileToCaseMap(Set<Id> contentDocIds) {

        Map<Id, Id> fileToCaseMap = new Map<Id, Id>();

        List<ContentDocumentLink> links = [
            SELECT LinkedEntityId, ContentDocumentId
            FROM ContentDocumentLink
            WHERE ContentDocumentId IN :contentDocIds
            AND LinkedEntityId IN (SELECT Id FROM Case)
        ];

        for (ContentDocumentLink link : links) {
            fileToCaseMap.put(link.ContentDocumentId, link.LinkedEntityId);
        }

        System.debug('üß† File ‚Üí Case Map: ' + fileToCaseMap);
        return fileToCaseMap;
    }

    /* ================= CORE ================= */

    private static void importVulnerabilityData(List<Id> contentDocIds) {

        Map<String, Schema.SObjectType> gd = Schema.getGlobalDescribe();
        if (!gd.containsKey(VULN_OBJECT_API)) {
            System.debug('‚ùå Object not found: ' + VULN_OBJECT_API);
            return;
        }

        Schema.SObjectType vulnType = gd.get(VULN_OBJECT_API);

        // ‚≠ê GET FILE ‚Üí CASE MAP
        Set<Id> docIdSet = new Set<Id>(contentDocIds);
        Map<Id, Id> fileToCaseMap = getFileToCaseMap(docIdSet);

        List<ContentVersion> versions = [
            SELECT Id, VersionData, ContentDocumentId
            FROM ContentVersion
            WHERE ContentDocumentId IN :contentDocIds
            AND IsLatest = true
        ];

        List<SObject> recordsToInsert = new List<SObject>();

        for (ContentVersion cv : versions) {

            Id relatedCaseId = fileToCaseMap.get(cv.ContentDocumentId);

            if (cv.VersionData == null) continue;

            String csv = cv.VersionData.toString()
                .replace('\r\n', '\n')
                .replace('\r', '\n');

            List<String> rows = csv.split('\n');
            if (rows.size() < 2) continue;

            Map<String, Integer> headerIndex = buildHeaderIndex(rows[0]);

            for (Integer i = 1; i < rows.size(); i++) {

                if (String.isBlank(rows[i])) continue;

                List<String> cols = parseCSVLine(rows[i]);

                String rule = getValue(cols, headerIndex, 'rule');
                String file = getValue(cols, headerIndex, 'file');

                if (String.isBlank(rule) || String.isBlank(file)) continue;

                SObject vuln = vulnType.newSObject();

                // ‚≠ê‚≠ê‚≠ê NEW ‚Äî LINK TO CASE ‚≠ê‚≠ê‚≠ê
                if (relatedCaseId != null) {
                    vuln.put('Case__c', relatedCaseId);
                }

                vuln.put('Rule__c', rule);
                vuln.put('Engine__c', getValue(cols, headerIndex, 'engine'));
                vuln.put('Severity__c', getValue(cols, headerIndex, 'severity'));
                vuln.put('Category__c', getValue(cols, headerIndex, 'tags'));
                vuln.put('File__c', file);
                vuln.put('Line__c', getValue(cols, headerIndex, 'startline'));
                vuln.put('Column__c', getValue(cols, headerIndex, 'startcolumn'));
                vuln.put('Description__c', getValue(cols, headerIndex, 'message'));
                vuln.put('URL__c', getValue(cols, headerIndex, 'resources'));
                vuln.put('Commit__c', getValue(cols, headerIndex, 'commitauthor'));
                vuln.put('ActualLine__c', getValue(cols, headerIndex, 'actualline'));
                vuln.put('TargetBranch__c', getValue(cols, headerIndex, 'targetbranch'));
                //vuln.put('Violation_Status__c', 'Open');

                recordsToInsert.add(vuln);
            }
        }

        if (!recordsToInsert.isEmpty()) {
            Database.insert(recordsToInsert, false);
            System.debug('‚úÖ Vulnerabilities inserted: ' + recordsToInsert.size());
        }
    }

    /* ================= HELPERS ================= */

    private static Map<String, Integer> buildHeaderIndex(String header) {
        Map<String, Integer> indexMap = new Map<String, Integer>();
        List<String> headers = parseCSVLine(header);
        for (Integer i = 0; i < headers.size(); i++) {
            indexMap.put(normalize(headers[i]), i);
        }
        return indexMap;
    }

    private static String getValue(List<String> row, Map<String, Integer> headerIndex, String key) {
        String normalizedKey = normalize(key);
        if (headerIndex.containsKey(normalizedKey)
            && headerIndex.get(normalizedKey) < row.size()) {
            return row[headerIndex.get(normalizedKey)];
        }
        return null;
    }

    private static String normalize(String s) {
        return s == null ? '' :
            s.toLowerCase().replace(' ', '').replace('_', '').replace('-', '');
    }

    private static List<String> parseCSVLine(String line) {
        List<String> cols = new List<String>();
        Boolean inQuotes = false;
        String cur = '';

        for (Integer i = 0; i < line.length(); i++) {
            String c = line.substring(i, i + 1);
            if (c == '"') inQuotes = !inQuotes;
            else if (c == ',' && !inQuotes) {
                cols.add(cur.trim());
                cur = '';
            } else cur += c;
        }

        cols.add(cur.trim());
        return cols;
    }

    /* ===== EXISTING SCANNER REPORT CASE CREATION (UNCHANGED) ===== */
    private static void createScannerReportCases(Set<Id> contentDocIds) {

        List<ContentDocument> docs = [
            SELECT Id, Title
            FROM ContentDocument
            WHERE Id IN :contentDocIds
        ];

        List<Scanner_Report_Case__c> casesToInsert = new List<Scanner_Report_Case__c>();

        for (ContentDocument doc : docs) {

            if (doc.Title != null && doc.Title.contains('Code_Scanner_Report')) {

                List<Scanner_Report_Case__c> existing = [
                    SELECT Id FROM Scanner_Report_Case__c
                    WHERE File_Id__c = :doc.Id LIMIT 1
                ];

                if (!existing.isEmpty()) continue;

                Scanner_Report_Case__c newCase = new Scanner_Report_Case__c();
                newCase.File_Id__c = doc.Id;
                newCase.File_Name__c = doc.Title;
                newCase.Status__c = 'New';
                newCase.OwnerId = UserInfo.getUserId();

                casesToInsert.add(newCase);
            }
        }

        if (!casesToInsert.isEmpty()) {
            insert casesToInsert;
        }
    }
}

--------------------------------------------------------------------------------------------------------------------------
public with sharing class File {

    public static void processNewFiles(List<ContentVersion> contentVersions) {
        List<Id> contentDocIds = new List<Id>();

        for (ContentVersion file : contentVersions) {
            if (file.ContentDocumentId != null) {
                contentDocIds.add(file.ContentDocumentId);
            }
        }

        if (!contentDocIds.isEmpty()) {
            importVulnerabilityData(contentDocIds);
        }
    }

    public static void importVulnerabilityData(List<Id> contentDocIds) {
        try {
            List<ContentVersion> fileList = [
                SELECT Id, VersionData, ContentDocumentId
                FROM ContentVersion
                WHERE ContentDocumentId IN :contentDocIds
                ORDER BY CreatedDate DESC
            ];

            if (fileList.isEmpty()) return;

            List<Vulnerability__c> newRecords = new List<Vulnerability__c>();

            for (ContentVersion file : fileList) {
                if (file.VersionData == null) continue;

                String csvContent = file.VersionData.toString();
                List<String> lines = csvContent.split('\n');
                if (lines.isEmpty()) continue;

                // Parse headers
                List<String> headers = parseCSVLine(lines[0]);
                Map<String, Integer> columnMap = new Map<String, Integer>();

                for (Integer i = 0; i < headers.size(); i++) {
                    columnMap.put(headers[i].trim().toLowerCase(), i);  // Case-insensitive mapping
                }

                // V5 field mapping
                Map<String, String> fieldMappings = new Map<String, String>{
                    'rule'         => 'rule',
                    'engine'       => 'engine',
                    'severity'     => 'severity',
                    'tags'         => 'category',
                    'file'         => 'file',
                    'startline'    => 'line',
                    'startcolumn'  => 'column',
                    'message'      => 'description',
                    'resources'    => 'url',
                    'commit'       => 'commit',
                    'actualline'   => 'actual line',
                    'targetbranch' => 'target branch'
                };

                // Validate required headers
                for (String key : fieldMappings.keySet()) {
                    if (!columnMap.containsKey(key)) {
                        //System.debug('‚ö†Ô∏è Missing required column: ' + key);
                        return;
                    }
                }

                for (Integer i = 1; i < lines.size(); i++) {
                    List<String> columns = parseCSVLine(lines[i]);
                    if (columns.size() < headers.size()) continue;

                    Vulnerability__c vuln = new Vulnerability__c();
                    vuln.Rule__c          = columns[columnMap.get('rule')].trim();
                    vuln.Engine__c        = columns[columnMap.get('engine')].trim();
                    vuln.Severity__c      = columns[columnMap.get('severity')].trim();
                    vuln.Category__c      = columns[columnMap.get('tags')].trim();
                    vuln.File__c          = columns[columnMap.get('file')].trim();
                    vuln.Line__c          = columns[columnMap.get('startline')].trim();
                    vuln.Column__c        = columns[columnMap.get('startcolumn')].trim();
                    vuln.Description__c   = columns[columnMap.get('message')].trim();
                    vuln.URL__c           = columns[columnMap.get('resources')].trim();
                    vuln.Commit__c        = columns[columnMap.get('commit')].trim();
                    vuln.ActualLine__c    = columns[columnMap.get('actualline')].trim();
                    vuln.TargetBranch__c  = columns[columnMap.get('targetbranch')].trim();

                    newRecords.add(vuln);
                }
            }

            if (!newRecords.isEmpty()) {
                insert newRecords;
            }

        } catch (Exception e) {
            //System.debug('‚ö†Ô∏è Error importing vulnerability data: ' + e.getMessage());
        }
    }

    // CSV Parsing Utility - Handles commas inside quoted fields
    public static List<String> parseCSVLine(String csvLine) {
        List<String> columns = new List<String>();
        Boolean insideQuote = false;
        String currentValue = '';

        for (Integer i = 0; i < csvLine.length(); i++) {
            String currentChar = csvLine.substring(i, i + 1);

            if (currentChar == '"') {
                insideQuote = !insideQuote;
            } else if (currentChar == ',' && !insideQuote) {
                columns.add(currentValue.trim());
                currentValue = '';
            } else {
                currentValue += currentChar;
            }
        }

        columns.add(currentValue.trim());
        return columns;
    }
}
