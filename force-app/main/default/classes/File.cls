public with sharing class File {

    private static final String VULN_OBJECT = 'Vulnerability__c';

    /* ================= ENTRY ================= */
    public static void processNewFiles(List<ContentVersion> newFiles) {
        Set<Id> docIds = new Set<Id>();
        for (ContentVersion cv : newFiles) {
            if (cv.ContentDocumentId != null) {
                docIds.add(cv.ContentDocumentId);
            }
        }
        if (!docIds.isEmpty()) {
            System.enqueueJob(new ImportJob(new List<Id>(docIds)));
        }
    }

    /* ================= QUEUEABLE ================= */
    public class ImportJob implements Queueable {

        private List<Id> docIds;

        public ImportJob(List<Id> docIds) {
            this.docIds = docIds;
        }

        public void execute(QueueableContext qc) {
            importCsv(docIds);
        }
    }

    /* ================= CORE ================= */
    private static void importCsv(List<Id> docIds) {

        if (!Schema.getGlobalDescribe().containsKey(VULN_OBJECT)) {
            System.debug('‚ùå Vulnerability__c does not exist');
            return;
        }

        Schema.SObjectType sType =
            Schema.getGlobalDescribe().get(VULN_OBJECT);

        List<ContentVersion> files = [
            SELECT Id, Title, FileExtension, VersionData
            FROM ContentVersion
            WHERE ContentDocumentId IN :docIds
            AND IsLatest = true
        ];

        for (ContentVersion cv : files) {

            if (cv.VersionData == null || cv.FileExtension != 'csv') continue;

            String csv = cv.VersionData.toString()
                .replace('\r\n','\n')
                .replace('\r','\n');

            List<String> rows = csv.split('\n');
            if (rows.size() < 2) continue;

            Map<String,Integer> headerIndex = buildHeaderIndex(rows[0]);
            List<SObject> records = new List<SObject>();

            for (Integer i = 1; i < rows.size(); i++) {

                if (String.isBlank(rows[i])) continue;

                List<String> cols = parseCSVLine(rows[i]);

                String fileName = getValue(cols, headerIndex, 'file');
                String problem  = getValue(cols, headerIndex, 'problem');

                if (String.isBlank(fileName) || String.isBlank(problem)) continue;

                SObject v = sType.newSObject();
                v.put('Problem__c', problem);
                v.put('File__c', fileName);
                v.put('Severity__c', getValue(cols, headerIndex, 'severity'));
                v.put('Rule__c', getValue(cols, headerIndex, 'rule'));
                v.put('Category__c', getValue(cols, headerIndex, 'category'));
                v.put('Engine__c', getValue(cols, headerIndex, 'engine'));
                v.put('Commit__c', getValue(cols, headerIndex, 'commit'));

                // üî• THIS WAS THE BREAKING ISSUE
                v.put('Line__c', getValue(cols, headerIndex, 'templine'));

                v.put('Column__c', getValue(cols, headerIndex, 'column'));
                v.put('ActualLine__c', getValue(cols, headerIndex, 'actualline'));
                v.put('TargetBranch__c', getValue(cols, headerIndex, 'targetbranch'));
                v.put('Repo__c', getValue(cols, headerIndex, 'repo'));

                v.put('Violation_Status__c', 'Open');

                records.add(v);
            }

            if (records.isEmpty()) {
                System.debug('‚ö†Ô∏è NO RECORDS CREATED ‚Äì CHECK CSV HEADERS');
                continue;
            }

            Database.SaveResult[] results =
                Database.insert(records, false);

            for (Database.SaveResult r : results) {
                if (!r.isSuccess()) {
                    for (Database.Error e : r.getErrors()) {
                        System.debug('‚ùå INSERT ERROR: ' + e.getMessage());
                    }
                }
            }

            System.debug('‚úÖ INSERTED RECORD COUNT: ' + records.size());
        }
    }

    /* ================= HELPERS ================= */

    private static Map<String,Integer> buildHeaderIndex(String header) {
        Map<String,Integer> mapIdx = new Map<String,Integer>();
        List<String> headers = parseCSVLine(header);
        for (Integer i = 0; i < headers.size(); i++) {
            mapIdx.put(normalize(headers[i]), i);
        }
        return mapIdx;
    }

    private static String getValue(
        List<String> row,
        Map<String,Integer> idx,
        String key
    ) {
        String k = normalize(key);
        return idx.containsKey(k) && idx.get(k) < row.size()
            ? row[idx.get(k)]
            : null;
    }

    private static String normalize(String s) {
        return s == null ? ''
            : s.toLowerCase()
                .replace(' ','')
                .replace('_','')
                .replace('-','');
    }

    private static List<String> parseCSVLine(String line) {
        List<String> cols = new List<String>();
        Boolean inQuotes = false;
        String cur = '';
        for (Integer i = 0; i < line.length(); i++) {
            String c = line.substring(i,i+1);
            if (c == '"') inQuotes = !inQuotes;
            else if (c == ',' && !inQuotes) {
                cols.add(cur.trim());
                cur = '';
            } else cur += c;
        }
        cols.add(cur.trim());
        return cols;
    }
}
